





###   数组和集合的区别

- 相同点

  都是容器,可以存储多个数据

- 不同点

  - 数组的长度是不可变的,集合的长度是可变的

  - 数组可以存基本数据类型和引用数据类型

    集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类



# *单列集合体系结构*

![image-20230219140621827](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219140621827.png)

###  list集合：有索引，可重复，添加元素有序。

### Set集合 ：无索引，不可重复，添加元素没有顺序。



Collection集合常用方法

| 方法名                     | 说明                               |
| :------------------------- | :--------------------------------- |
| boolean add(E e)           | 添加元素                           |
| boolean remove(Object o)   | 从集合中移除指定的元素             |
| boolean removeIf(Object o) | 根据条件进行移除                   |
| void   clear()             | 清空集合中的元素                   |
| boolean contains(Object o) | 判断集合中是否存在指定的元素       |
| boolean isEmpty()          | 判断集合是否为空                   |
| int   size()               | 集合的长度，也就是集合中元素的个数 |

*contains默认使用的是obj类的equals方法判断，判断的是地址值。存自定义对象时要重写equals方法*





### List集合的特有方法【应用】

- 方法介绍

  | 方法名                          | 描述                                   |
  | ------------------------------- | -------------------------------------- |
  | void add(int index,E   element) | 在此集合中的指定位置插入指定的元素     |
  | E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |
  | E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |
  | E get(int   index)              | 返回指定索引处的元素                   |



```java


public class MyListDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
        //method1(list);
        //method2(list);
        //method3(list);
        //method4(list);
    }

private static void method4(List<String> list) {
    //        E get(int index)		返回指定索引处的元素
    String s = list.get(0);
    System.out.println(s);
}

private static void method3(List<String> list) {
    //        E set(int index,E element)	修改指定索引处的元素，返回被修改的元素
    //被替换的那个元素,在集合中就不存在了.
    String result = list.set(0, "qqq");
    System.out.println(result);
    System.out.println(list);
}

private static void method2(List<String> list) {
    //        E remove(int index)		删除指定索引处的元素，返回被删除的元素
    //在List集合中有两个删除的方法
    //第一个 删除指定的元素,返回值表示当前元素是否删除成功
    //第二个 删除指定索引的元素,返回值表示实际删除的元素
    String s = list.remove(0);
    System.out.println(s);
    System.out.println(list);
}

private static void method1(List<String> list) {
    //        void add(int index,E element)	在此集合中的指定位置插入指定的元素
    //原来位置上的元素往后挪一个索引.
    list.add(0,"qqq");
    System.out.println(list);
}
}
```
#### ArrayList集合

![image-20230219143825120](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219143825120.png)



扩容原理

![image-20230219145135084](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219145135084.png)





#### LinkedList集合

![image-20230219145315038](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219145315038.png)



扩容原理

![LinkedList源码分析](https://gitee.com/dwc12/image/raw/master/typoraImage/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png)



```Java
public boolean add(E e) {
    linkLast(e);
    return true;
}

void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null); //prev ,item ,next
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++; //集合操作次数
    }
```

#### 扩展 泛型

  泛型的好处  统一数据类型。把编译时期的问题提前到了编译区间，避免了强制类型转换出现的异常，因为在编译阶段类型就能确定下来。 java的泛型是伪泛型。



### Set系列集合

 ![image-20230219154028336](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219154028336.png)



#### HashSet集合原理      数组+链表+红黑树

```java
  public class MySet1 {
    public static void main(String[] args) {
      	//创建集合对象
        Set<String> set = new TreeSet<>();
      	//添加元素
        set.add("ccc");
        set.add("aaa");
        set.add("aaa");
        set.add("bbb");

//        for (int i = 0; i < set.size(); i++) {
//            //Set集合是没有索引的，所以不能使用通过索引获取元素的方法
//        }
  //遍历集合
    Iterator<String> it = set.iterator();
    while (it.hasNext()){
        String s = it.next();
        System.out.println(s);
    }
    System.out.println("-----------------------------------");
    for (String s : set) {
        System.out.println(s);
    }
}
```
![image-20230219155243774](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219155243774.png)



![image-20230219155554418](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219155554418.png)

index = (数组长度 -1) & hashcode

JDK8以后后来的元素直接添加子已有元素的后面，形成链表。当链表长度大于8切数组长度大于64，链表转化为红黑树。

存储自定义对象时一定要重写hashcode和equals方法，默认通过地址值计算，重写后根据属性计算。





#### LinkedHashSet集合原理

![image-20230219202100001](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230219202100001.png)

保证了存储和去除数据有序。





#### TreeSet集合原理

​    可排序，不重复，无索引   基于红黑树

### TreeSet集合概述和特点【应用】

+ 不可以存储重复元素
+ 没有索引
+ 可以将元素按照规则进行排序
  + TreeSet()：根据其元素的自然排序进行排序
  + TreeSet(Comparator comparator) ：根据指定的比较器进行排序

### 存储Integer类型的整数并遍历

```java
public class TreeSetDemo01 {
    public static void main(String[] args) {
        //创建集合对象
        TreeSet<Integer> ts = new TreeSet<Integer>();

        //添加元素
        ts.add(10);
        ts.add(40);
        ts.add(30);
        ts.add(50);
        ts.add(20);

        ts.add(30);

        //遍历集合
        for(Integer i : ts) {
            System.out.println(i);
        }
    }
}
```

### 自然排序Comparable的使用【应用】

- 案例需求

  - 存储学生对象并遍历，创建TreeSet集合使用无参构造方法
  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序

- 实现步骤

  1. 使用空参构造创建TreeSet集合
     + 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的
  2. 自定义的Student类实现Comparable接口
     + 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法
  3. 重写接口中的compareTo方法
     + 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写

- 代码实现

  学生类

  ```java
  public class Student implements Comparable<Student>{
      private String name;
      private int age;
  
      public Student() {
      }
  
      public Student(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "Student{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  
      @Override
      public int compareTo(Student o) {
          //按照对象的年龄进行排序
          //主要判断条件: 按照年龄从小到大排序
          int result = this.age - o.age;
          //次要判断条件: 年龄相同时，按照姓名的字母顺序排序
          result = result == 0 ? this.name.compareTo(o.getName()) : result;
          return result;
      }
  }
  ```

  测试类

  ```java
  public class MyTreeSet2 {
      public static void main(String[] args) {
          //创建集合对象
          TreeSet<Student> ts = new TreeSet<>();
  	    //创建学生对象
          Student s1 = new Student("zhangsan",28);
          Student s2 = new Student("lisi",27);
          Student s3 = new Student("wangwu",29);
          Student s4 = new Student("zhaoliu",28);
          Student s5 = new Student("qianqi",30);
  		//把学生添加到集合
          ts.add(s1);
          ts.add(s2);
          ts.add(s3);
          ts.add(s4);
          ts.add(s5);
  		//遍历集合
          for (Student student : ts) {
              System.out.println(student);
          }
      }
  }
  ```

### 3.4比较器排序Comparator的使用【应用】

- 案例需求

  - 存储老师对象并遍历，创建TreeSet集合使用带参构造方法
  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序

- 实现步骤

  - 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的
  - 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法
  - 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写

- 代码实现

  老师类

  ```java
  public class Teacher {
      private String name;
      private int age;
  
      public Teacher() {
      }
  
      public Teacher(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public String toString() {
          return "Teacher{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  ```

  测试类

  ```java
  public class MyTreeSet4 {
      public static void main(String[] args) {
        	//创建集合对象
          TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {
              @Override
              public int compare(Teacher o1, Teacher o2) {
                  //o1表示现在要存入的那个元素
                  //o2表示已经存入到集合中的元素
                
                  //主要条件
                  int result = o1.getAge() - o2.getAge();
                  //次要条件
                  result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;
                  return result;
              }
          });
  		//创建老师对象
          Teacher t1 = new Teacher("zhangsan",23);
          Teacher t2 = new Teacher("lisi",22);
          Teacher t3 = new Teacher("wangwu",24);
          Teacher t4 = new Teacher("zhaoliu",24);
  		//把老师添加到集合
          ts.add(t1);
          ts.add(t2);
          ts.add(t3);
          ts.add(t4);
  		//遍历集合
          for (Teacher teacher : ts) {
              System.out.println(teacher);
          }
      }
  }
  ```

### 两种比较方式总结【理解】

+ 两种比较方式小结
  + 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序
  + 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序
  + 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序
+ 两种方式中关于返回值的规则
  + 如果返回值为负数，表示当前存入的元素是较小值，存左边
  + 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存
  + 如果返回值为正数，表示当前存入的元素是较大值，存右边