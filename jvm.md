#  jvm的基本结构

JVM由三个主要的子系统构成

1. 类加载器子系统  （即将class文件加载到虚拟机内存）
   - **启动类加载器**：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等
   - **扩展类加载器**：负责加载JRE扩展目录ext中JAR类包
   - **系统类加载器**：负责加载ClassPath路径下的类包
   - **用户自定义加载器**：负责加载用户自定义路径下的类包
2. 运行时数据区（内存结构）
3. 执行引擎

![image-20230225165659938](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230225165659938.png)

1. **本地方法栈(线程私有)：登记native方法，在Execution Engine执行时加载本地方法库
2. 程序计数器（线程私有）：就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
3. 方法区(线程共享)：类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。
4. Java栈（线程私有）： Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致
5. JVM对该区域（栈）规范了两种异常：

        1) 线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverFlowError异常
        
        2) 若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError，通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度


# 运行时数据区

##    1   程序计数器（寄存器）

​      做用：  记住下一条jvm指令的地址

![image-20230225174838603](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230225174838603.png)

​    **特点：**

- ​     时线程私有的    每个线程都有自己的程序计数器
- ​    唯一一个不存在内存溢出的区





## 2     jvm虚拟机栈

  线程运行时需要的内存空间。

  栈里存储栈帧，当运行方法时对应的栈帧（每个方法运行时需要的内存）入栈，方法执行完后出栈

![image-20230225180355502](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230225180355502.png)

**特点：**

- 每个线程只能有一个活动的栈帧（栈顶部的栈帧），对应着当前正在执行的方法
- 每个线程运行时需要的内存，称为虚拟机栈
- 栈帧 -------每个方法运行时需要的内存



**问题：**

-   不需要垃圾回收
-  栈内存不是越高越好，栈内存越高线程越少
-  如果变量没有逃离方法的作用范围，那么它是线程安全的

**栈内存溢出 ** （StackOverFlowError)

-   栈帧过多导致栈内存溢出
- 栈帧过大，也会导致栈内存溢出



**线程运行诊断**

1.cpu占用过高

  top: 查看进程状态  定位到进程

 ps H -eo pid.tid,%cpu   :   查看线程，进程，cpu占用率

 ps H -eo pid.tid,%cpu | grep pid ： 过滤想要看的线程

jstack  <pid>  : 查看当前进程对应虚拟机里的线程信息

​                          对比十六进制线程id找到相应的信息









## 3 本地方法栈 （native method stacks)

对非java方法运行时提供的空间





## 4  堆（heap）

   **定义**

-  通过new创建的对象都会使用堆内存

- 是线程共享的，堆中的对象都要考虑线程安全问题

- 有垃圾回收机制

  

  

  

  

**堆内存溢出** （OutOfMemoryError)

​    不断创建新的对象使用，最终导致堆内存溢出





**堆内存诊断**

1. jps工具
   - 查看当前系统有哪些java线程
2. jmap工具
   -  查看堆内存占用情况         -heap <进程id>

   3.jconsole工具

-  图形化界面，多功能检测工具，可以连续监测

  

**案例**

- 垃圾回收后，内存占用依然很高

   可以用jsisualvm工具排查具体对象





## 5  方法区（Method Area）







**定义 ** 

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

##### 



