#  jvm的基本结构

JVM由三个主要的子系统构成

1. 类加载器子系统  （即将class文件加载到虚拟机内存）
   - **启动类加载器**：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等
   - **扩展类加载器**：负责加载JRE扩展目录ext中JAR类包
   - **系统类加载器**：负责加载ClassPath路径下的类包
   - **用户自定义加载器**：负责加载用户自定义路径下的类包
2. 运行时数据区（内存结构）
3. 执行引擎

![image-20230225165659938](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230225165659938.png)

1. **本地方法栈(线程私有)：登记native方法，在Execution Engine执行时加载本地方法库
2. 程序计数器（线程私有）：就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
3. 方法区(线程共享)：类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。
4. Java栈（线程私有）： Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致
5. JVM对该区域（栈）规范了两种异常：

        1) 线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverFlowError异常
        
        2) 若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError，通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度


# 运行时数据区

##    1   程序计数器（寄存器）

​      做用：  记住下一条jvm指令的地址

![image-20230225174838603](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230225174838603.png)

​    **特点：**

- ​     时线程私有的    每个线程都有自己的程序计数器
- ​    唯一一个不存在内存溢出的区





## 2     jvm虚拟机栈

  线程运行时需要的内存空间。

  栈里存储栈帧，当运行方法时对应的栈帧（每个方法运行时需要的内存）入栈，方法执行完后出栈

![image-20230225180355502](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230225180355502.png)

**特点：**

- 每个线程只能有一个活动的栈帧（栈顶部的栈帧），对应着当前正在执行的方法
- 每个线程运行时需要的内存，称为虚拟机栈
- 栈帧 -------每个方法运行时需要的内存



**问题：**

-   不需要垃圾回收
-  栈内存不是越高越好，栈内存越高线程越少
-  如果变量没有逃离方法的作用范围，那么它是线程安全的

**栈内存溢出 ** （StackOverFlowError)

-   栈帧过多导致栈内存溢出
- 栈帧过大，也会导致栈内存溢出



**线程运行诊断**

1.cpu占用过高

  top: 查看进程状态  定位到进程

 ps H -eo pid.tid,%cpu   :   查看线程，进程，cpu占用率

 ps H -eo pid.tid,%cpu | grep pid ： 过滤想要看的线程

jstack  <pid>  : 查看当前进程对应虚拟机里的线程信息

​                          对比十六进制线程id找到相应的信息









## 3 本地方法栈 （native method stacks)

对非java方法运行时提供的空间





## 4  堆（heap）

 

  **定义**

-  通过new创建的对象都会使用堆内存

- 是线程共享的，堆中的对象都要考虑线程安全问题

- 有垃圾回收机制

- 对于大多数应用来说，Java 堆是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配内存。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

  


**堆内存溢出** （OutOfMemoryError)

​    不断创建新的对象使用，最终导致堆内存溢出

**堆内存诊断**

1. jps工具
   - 查看当前系统有哪些java线程
2. jmap工具
   -  查看堆内存占用情况         -heap <进程id>

   3.jconsole工具

-  图形化界面，多功能检测工具，可以连续监测

  

**案例**

- 垃圾回收后，内存占用依然很高

   可以用jsisualvm工具排查具体对象





## 5  方法区（Method Area）

**定义 ** 

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

![image-20230227185129544](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230227185129544.png)



**内存溢出**

![image-20230227185729369](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230227185729369.png)

一次性加载的类太多则会导致方法去内存溢出  MetaSpace

**场景**

- 在开发中 spring和mybatis在运行过程中会加载很多类，有可能会造成方法去内存溢出





## 6 运行时常量池

**定义**

- 常量池就是一张表，虚拟机指令根据这张表找到要执行的方法，类名，方法名，参数类型，字面量等信息
- 运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。
- 运行时常量池，存在于方法区





## 7 StringTable （串池）

![image-20230227194858337](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230227194858337.png)

​     答案： false，true，true，false 如果最后两行换位置则为 true

**特性**

- 常量池中的字符串仅是符号，第一次用到时才变为对象
- 利用串池机制，来避免重复创建字符串对象
- 字符串拼接的原理是StringBuilder（1.8）
- 字符串常量拼接的原理是编译器优化
- 可以使用intern方法，主动将传池中还没有的对象放入串池
  - 1.8 将对象放入串池，没有则放入，有则不放入
  - 1.6  将对象放入串池，没有则将对象复制一份，放入串池，有则不放入



**位置**

   jdk1.8之后将stringtable放入了堆中，增加了垃圾回收的效率

​    1.6 串池存在于永久代



**垃圾回收机制**

   当stringtable内存不足时会触发gc垃圾回收





**性能调优**   		

- ​    stringtable底层是hashtable表实现的如果桶的个数很多那么存储的效率也会变高

​           调优参数  -XX: StringTableSize = "??"  设置桶的个数

-   考虑将字符串对象是否入池   如果有大量的字符串对象，并且有重复的可以考虑让对象入池会节省大量空间





## 8  直接内存  （Direct 	Memory）

 **定义**

-  常见于NIO操作，用于数据缓冲区
- 分配回收成本较高，但读写性能高
- 不受jvm内存回收管理

普通文件读写过程

![image-20230228154457048](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230228154457048.png)

直接缓冲区 ,在操作系统层面划一块缓冲区。java代码可以直接访问，读写速度得到了成倍的提升。

```java
ByteBuffer.allocateDirect(_1MB)
```

![image-20230228154527857](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230228154527857.png)







**分配和回收原理**

- 使用了Unsafe对象完成直接内存的分配和回收，并且回收需要调用freememory方法
- ByteBuffer的实现类内部，使用了Cleaner(虚引用)来检测ByteBuffer对象，一旦ByterBuffer对象被垃圾回收，那么就有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存





# 垃圾回收







## 1 如何判断对象可以回收

**引用计数法**

   如果对象引用多一个，计数就会加一当引用数为0时，被垃圾回收。

会造成循环引用，内存溢出

![image-20230228161249734](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230228161249734.png)

**可达性分析算法**

- java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
- 扫描堆中的对象，看看能否沿着gc root对象为起点的引用链找到该对象，找不到，表示可以回收
- 哪些对象可以作为gc root？
  -  系统类对象，本地方法对象，线程类对象，被加锁的对象（Busy Mointor），栈帧内使用的变量，被引用的对象





**四种引用**

-   强引用

    只有所有的gc root对喜爱那个都不通过强引用引用该对象，该对象才能被垃圾回收

- 弱引用

  -    不管内存够不够，都会回收弱引用对象   引用的对象被回收后会进入引用队列
  -    可以配合引用队列来释放弱引用自身

  

- 软引用

  -   垃圾回收时内存不够会回收软引用的对象，内存够则不会回收。 引用的对象被回收后会进入引用队列

  -    可以配合引用队列来释放软引用自身

- 虚引用

  -  ![image-20230228170221419](https://gitee.com/dwc12/image/raw/master/typoraImage/image-20230228170221419.png)
  - 当虚引用引用的对象被回收时，其进入引用队列，被遍历回收
  - 必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，有Reference Handler线程调用虚引用相关的方法释放直接内存





## 2  垃圾回收算法

  **标记清除**



  
